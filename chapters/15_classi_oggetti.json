{
  "id": "classi_oggetti",
  "title": "Classi e Oggetti (OOP): Modellare il Mondo Reale",
  "explanation": "<h2>Programmazione Orientata agli Oggetti (OOP)</h2>\n<p>La Programmazione Orientata agli Oggetti (OOP) è un paradigma di programmazione che si basa sul concetto di <strong>oggetti</strong>. Gli oggetti rappresentano entità del mondo reale o concetti astratti, e combinano <strong>dati</strong> (chiamati <strong>attributi</strong> o proprietà) e <strong>comportamenti</strong> (chiamati <strong>metodi</strong> o funzioni) che operano su quei dati.</p>\n<p>L'OOP aiuta a organizzare programmi complessi in modo più intuitivo, modulare e riutilizzabile.</p>\n\n<h2>Classi: I Progetti per gli Oggetti</h2>\n<p>Una <strong>classe</strong> è come un progetto, uno stampo o un modello per creare oggetti. Definisce quali attributi avranno gli oggetti di quel tipo e quali metodi potranno eseguire.</p>\n<p>Si definisce una classe usando la parola chiave <code>class</code>, seguita dal nome della classe (per convenzione, in stile <em>CamelCase</em>, es. <code>MiaClasse</code>) e i due punti <code>:</code>. Il corpo della classe è indentato.</p>\n<pre><code class=\"language-python\"># Definizione di una classe semplice 'Cane'\nclass Cane:\n    # Attributo di classe (condiviso da tutte le istanze)\n    specie = \"Canis familiaris\"\n\n    # Metodo speciale __init__ (il costruttore)\n    # Viene chiamato automaticamente quando si crea un nuovo oggetto Cane\n    def __init__(self, nome_cane, razza_cane, eta_cane=0):\n        # Attributi di istanza (specifici per ogni oggetto Cane)\n        self.nome = nome_cane\n        self.razza = razza_cane\n        self.eta = eta_cane\n        print(f\"È nato un cane di nome {self.nome}!\")\n\n    # Metodo di istanza (un comportamento dell'oggetto)\n    def abbaia(self):\n        print(f\"{self.nome} dice: Bau! Bau!\")\n\n    # Un altro metodo di istanza\n    def festeggia_compleanno(self):\n        self.eta += 1\n        print(f\"Buon compleanno {self.nome}! Ora hai {self.eta} anni.\")\n\n    # Metodo speciale __str__ (rappresentazione testuale dell'oggetto)\n    def __str__(self):\n        return f\"Cane(nome='{self.nome}', razza='{self.razza}', eta={self.eta})\"</code></pre>\n\n<h3>Il Metodo <code>__init__</code> (Costruttore)</h3>\n<p><code>__init__</code> è un metodo speciale (notare i doppi underscore) chiamato <strong>costruttore</strong>. Viene eseguito automaticamente quando crei un nuovo oggetto (istanza) della classe. Il suo scopo principale è inizializzare gli attributi dell'oggetto.</p>\n<p>Il primo parametro di <code>__init__</code> (e di tutti i metodi di istanza) è sempre <code>self</code>. <code>self</code> rappresenta l'istanza specifica dell'oggetto che si sta creando o su cui si sta operando. Usiamo <code>self.nome_attributo = valore</code> per creare e assegnare valori agli attributi dell'istanza.</p>\n\n<h3>Attributi di Istanza vs Attributi di Classe</h3>\n<ul>\n    <li><strong>Attributi di Istanza</strong> (es. <code>self.nome</code>, <code>self.razza</code>): Sono specifici per ogni singolo oggetto creato dalla classe. Ogni cane avrà il suo nome e la sua razza.</li>\n    <li><strong>Attributi di Classe</strong> (es. <code>specie</code>): Sono condivisi da tutte le istanze della classe. Tutti gli oggetti <code>Cane</code> avranno <code>specie</code> uguale a \"Canis familiaris\".</li>\n</ul>\n\n<h3>Metodi di Istanza</h3>\n<p>Sono funzioni definite all'interno della classe che definiscono i comportamenti degli oggetti. Ricevono sempre <code>self</code> come primo argomento, permettendo loro di accedere e modificare gli attributi dell'istanza specifica (es. <code>self.eta += 1</code> nel metodo <code>festeggia_compleanno</code>).</p>\n\n<h3>Il Metodo <code>__str__</code></h3>\n<p><code>__str__</code> è un altro metodo speciale. Definisce come l'oggetto deve essere rappresentato come stringa, ad esempio quando usi <code>print(oggetto)</code>. Se non lo definisci, <code>print()</code> mostrerà una rappresentazione generica meno utile.</p>\n\n<h2>Creare Oggetti (Istanze)</h2>\n<p>Una volta definita la classe, puoi creare oggetti (chiamati <strong>istanze</strong>) chiamando la classe come se fosse una funzione, passando gli argomenti richiesti dal metodo <code>__init__</code> (escluso <code>self</code>, che viene passato automaticamente).</p>\n<pre><code class=\"language-python\"># Creiamo due istanze (oggetti) della classe Cane\nmio_cane = Cane(\"Fido\", \"Labrador\", 3)\naltro_cane = Cane(\"Luna\", \"Golden Retriever\") # Usa eta=0 di default\n\n# mio_cane e altro_cane sono due oggetti distinti, \n# ognuno con i propri attributi nome, razza, eta.</code></pre>\n\n<h2>Accedere ad Attributi e Metodi</h2>\n<p>Usi la <strong>notazione col punto</strong> (<code>.</code>) sull'oggetto per accedere ai suoi attributi o chiamare i suoi metodi.</p>\n<pre><code class=\"language-python\"># Accedere agli attributi\nprint(f\"Il nome del mio cane è: {mio_cane.nome}\")\nprint(f\"La razza dell'altro cane è: {altro_cane.razza}\")\nprint(f\"Specie di entrambi (attributo di classe): {mio_cane.specie}, {altro_cane.specie}\")\n\n# Chiamare i metodi\nmio_cane.abbaia() # Output: Fido dice: Bau! Bau!\naltro_cane.abbaia() # Output: Luna dice: Bau! Bau!\n\nmio_cane.festeggia_compleanno() # Output: Buon compleanno Fido! Ora hai 4 anni.\nprint(f\"Nuova età di Fido: {mio_cane.eta}\") # Output: 4\n\n# Usare __str__ con print()\nprint(mio_cane) # Output: Cane(nome='Fido', razza='Labrador', eta=4)\nprint(altro_cane) # Output: Cane(nome='Luna', razza='Golden Retriever', eta=0)</code></pre>\n<p>L'OOP permette di modellare entità complesse in modo organizzato. Concetti più avanzati come l'<strong>ereditarietà</strong> (creare classi che ereditano attributi e metodi da altre classi) e il <strong>polimorfismo</strong> (oggetti di classi diverse che rispondono allo stesso metodo in modi diversi) rendono l'OOP ancora più potente, ma vanno oltre questa introduzione.</p>",
  "exercise": "<p>1. Definisci una classe chiamata <code>Libro</code>.</p>\n<p>2. Nel metodo <code>__init__</code>, la classe deve accettare <code>titolo</code> (stringa), <code>autore</code> (stringa) e <code>numero_pagine</code> (int) come parametri e memorizzarli come attributi dell'istanza.</p>\n<p>3. Aggiungi un metodo chiamato <code>descrizione</code> che restituisca una stringa formattata tipo: \"'[Titolo]' di [Autore], [Numero] pagine.\"</p>\n<p>4. Aggiungi un metodo <code>__str__</code> che restituisca una rappresentazione simile a quella del metodo <code>descrizione</code>.</p>\n<p>5. Crea due istanze della classe <code>Libro</code> con dati a tua scelta.</p>\n<p>6. Chiama il metodo <code>descrizione()</code> su una delle istanze e stampa il risultato.</p>\n<p>7. Usa <code>print()</code> direttamente sulla seconda istanza per vedere l'output del metodo <code>__str__</code>.</p>",
  "defaultCode": "# 1. Definisci la classe Libro\nclass Libro:\n    # 2. Metodo __init__\n    def __init__(self, titolo, autore, numero_pagine):\n        self.titolo = titolo\n        self.autore = autore\n        self.numero_pagine = numero_pagine\n        print(f\"Libro '{self.titolo}' creato.\")\n\n    # 3. Metodo descrizione\n    def descrizione(self):\n        return f\"'{self.titolo}' di {self.autore}, {self.numero_pagine} pagine.\"\n\n    # 4. Metodo __str__\n    def __str__(self):\n        # Possiamo riutilizzare il metodo descrizione!\n        return self.descrizione()\n\n# 5. Crea due istanze\nlibro1 = Libro(\"Il Signore degli Anelli\", \"J.R.R. Tolkien\", 1200)\nlibro2 = Libro(\"Guida Galattica per Autostoppisti\", \"Douglas Adams\", 250)\n\nprint(\"\n-- Test Metodi --\")\n# 6. Chiama descrizione() su libro1\ndesc_libro1 = libro1.descrizione()\nprint(f\"Descrizione Libro 1: {desc_libro1}\")\n\n# 7. Usa print() su libro2 (chiama __str__)\nprint(f\"Print Libro 2: {libro2}\")"
}
