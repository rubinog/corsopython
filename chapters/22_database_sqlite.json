{
  "id": "database_sqlite",
  "title": "Database con SQLite: Memorizzare Dati Strutturati",
  "explanation": "<h2>Database con SQLite: Un Database nel Tuo Script</h2>\n<p>Spesso abbiamo bisogno di memorizzare dati in modo strutturato e persistente, andando oltre semplici file di testo o CSV. I <strong>database relazionali</strong> sono progettati per questo, organizzando i dati in tabelle con righe e colonne, e permettendo query complesse per recuperare e manipolare i dati usando il linguaggio <strong>SQL (Structured Query Language)</strong>.</p>\n<p><strong>SQLite</strong> è un sistema di gestione di database (DBMS) molto popolare perché è:</p>\n<ul>\n    <li><strong>Serverless:</strong> Non richiede un processo server separato. L'intero database è contenuto in un singolo file sul disco.</li>\n    <li><strong>Leggero e Veloce:</strong> Ottimo per applicazioni embedded, prototipazione, o quando non serve la complessità di un database server completo (come PostgreSQL o MySQL).</li>\n    <li><strong>Integrato in Python:</strong> Python include il modulo <code>sqlite3</code> nella sua libreria standard, rendendo facilissimo interagire con database SQLite.</li>\n</ul>\n<p><strong>⚠️ Limitazioni nel Browser (Pyodide):</strong> Come per l'I/O su file, Pyodide non può creare o accedere direttamente a file <code>.db</code> o <code>.sqlite</code> sul filesystem locale per motivi di sicurezza. Tuttavia, <code>sqlite3</code> in Pyodide può creare e usare un database interamente <strong>in memoria</strong> specificando <code>':memory:'</code> come nome del file di connessione. Questo database è temporaneo e viene perso alla fine dell'esecuzione dello script, ma è perfetto per sperimentare con SQL e il modulo <code>sqlite3</code> in questo ambiente.</p>\n\n<h2>Flusso di Lavoro Base con <code>sqlite3</code></h2>\n<ol>\n    <li><strong>Importare il modulo:</strong> <code>import sqlite3</code></li>\n    <li><strong>Connettersi al database:</strong> <code>conn = sqlite3.connect('nome_database.db')</code> (o <code>':memory:'</code>). Questo crea l'oggetto connessione.</li>\n    <li><strong>Creare un cursore:</strong> <code>cursor = conn.cursor()</code>. Il cursore è l'oggetto che usiamo per eseguire comandi SQL.</li>\n    <li><strong>Eseguire comandi SQL:</strong> <code>cursor.execute(\"COMANDO SQL QUI...\")</code>. Comandi comuni includono <code>CREATE TABLE</code>, <code>INSERT INTO</code>, <code>SELECT</code>, <code>UPDATE</code>, <code>DELETE</code>.</li>\n    <li><strong>Recuperare risultati (per <code>SELECT</code>):</strong> Usare <code>cursor.fetchone()</code> (una riga), <code>cursor.fetchall()</code> (tutte le righe come lista di tuple), o iterare sul cursore.</li>\n    <li><strong>Salvare le modifiche (Commit):</strong> Per comandi che modificano i dati (<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>), è necessario chiamare <code>conn.commit()</code> per rendere le modifiche permanenti nel database.</li>\n    <li><strong>Chiudere la connessione:</strong> <code>conn.close()</code>. È importante rilasciare le risorse quando hai finito. Usare <code>with</code> con la connessione può aiutare a gestire commit e chiusura (anche se meno comune rispetto all'I/O su file).</li>\n</ol>\n\n<h2>Esempio Pratico (Database in Memoria)</h2>\n\n<h3>1. Connessione e Cursore</h3>\n<pre><code class=\"language-python\">import sqlite3\n\nconn = None # Buona pratica inizializzare a None\ntry:\n    # Connessione a DB in memoria\n    conn = sqlite3.connect(':memory:')\n    cursor = conn.cursor()\n    print(\"Connessione al DB in memoria stabilita.\")\nexcept sqlite3.Error as e:\n    print(f\"Errore durante la connessione: {e}\")\n    # Qui potresti voler uscire se la connessione fallisce\n    exit() # exit() non è ideale nel browser, ma concettualmente sì</code></pre>\n\n<h3>2. Creare una Tabella (<code>CREATE TABLE</code>)</h3>\n<p>Definiamo la struttura della nostra tabella usando SQL.</p>\n<pre><code class=\"language-python\">try:\n    cursor.execute(\"\"\"\n        CREATE TABLE IF NOT EXISTS prodotti (\n            id INTEGER PRIMARY KEY, \n            nome TEXT NOT NULL, \n            prezzo REAL, \n            quantita INTEGER DEFAULT 0\n        )\n    \"\"\")\n    # INTEGER PRIMARY KEY: ID numerico auto-incrementante (in SQLite)\n    # TEXT NOT NULL: Stringa obbligatoria\n    # REAL: Numero decimale\n    # INTEGER DEFAULT 0: Intero con valore predefinito 0\n    \n    conn.commit() # Necessario anche per CREATE TABLE\n    print(\"Tabella 'prodotti' creata o già esistente.\")\nexcept sqlite3.Error as e:\n    print(f\"Errore durante CREATE TABLE: {e}\")</code></pre>\n\n<h3>3. Inserire Dati (<code>INSERT INTO</code>)</h3>\n<p>È fondamentale usare i <strong>placeholder</strong> (<code>?</code>) per inserire valori nelle query SQL. Questo previene vulnerabilità di sicurezza note come <strong>SQL Injection</strong>.</p>\n<pre><code class=\"language-python\">try:\n    # Inserire un singolo prodotto\n    prodotto1 = ('Laptop', 999.90, 10)\n    cursor.execute(\"INSERT INTO prodotti (nome, prezzo, quantita) VALUES (?, ?, ?)\", prodotto1)\n    \n    # Inserire più prodotti con executemany\n    prodotti_da_inserire = [\n        ('Tastiera', 75.00, 50),\n        ('Mouse', 25.50, 100),\n        ('Monitor', 250.00) # Usa quantita DEFAULT 0\n    ]\n    cursor.executemany(\"INSERT INTO prodotti (nome, prezzo, quantita) VALUES (?, ?, ?)\", prodotti_da_inserire)\n    \n    conn.commit() # Salva tutti gli inserimenti\n    print(f\"{cursor.rowcount} righe inserite con executemany.\") # rowcount per executemany\n    print(\"Prodotti inseriti.\")\nexcept sqlite3.Error as e:\n    print(f\"Errore durante INSERT: {e}\")</code></pre>\n\n<h3>4. Interrogare Dati (<code>SELECT</code>)</h3>\n<p>Recuperiamo i dati inseriti.</p>\n<pre><code class=\"language-python\">try:\n    print(\"\n--- Prodotti nel database ---\")\n    cursor.execute(\"SELECT * FROM prodotti\")\n    tutti_prodotti = cursor.fetchall() # Lista di tuple\n    for prodotto in tutti_prodotti:\n        print(prodotto)\n        \n    print(\"\n--- Prodotti con prezzo > 50 ---\")\n    prezzo_min = 50\n    cursor.execute(\"SELECT nome, prezzo FROM prodotti WHERE prezzo > ? ORDER BY prezzo DESC\", (prezzo_min,))\n    # Nota la virgola in (prezzo_min,) per creare una tupla con un solo elemento\n    prodotti_costosi = cursor.fetchall()\n    for nome, prezzo in prodotti_costosi:\n        print(f\"- {nome}: {prezzo:.2f} euro\")\n        \n    print(\"\n--- Singolo prodotto (Mouse) ---\")\n    cursor.execute(\"SELECT * FROM prodotti WHERE nome = ?\", ('Mouse',))\n    mouse = cursor.fetchone() # Prende solo la prima riga trovata\n    if mouse:\n        print(mouse)\n    else:\n        print(\"Mouse non trovato.\")\n        \nexcept sqlite3.Error as e:\n    print(f\"Errore durante SELECT: {e}\")</code></pre>\n\n<h3>5. Aggiornare Dati (<code>UPDATE</code>)</h3>\n<pre><code class=\"language-python\">try:\n    nuovo_prezzo_mouse = 29.99\n    nome_prodotto_da_aggiornare = 'Mouse'\n    cursor.execute(\"UPDATE prodotti SET prezzo = ? WHERE nome = ?\", (nuovo_prezzo_mouse, nome_prodotto_da_aggiornare))\n    conn.commit()\n    print(f\"\nPrezzo di '{nome_prodotto_da_aggiornare}' aggiornato a {nuovo_prezzo_mouse}. Righe modificate: {cursor.rowcount}\")\nexcept sqlite3.Error as e:\n    print(f\"Errore durante UPDATE: {e}\")</code></pre>\n\n<h3>6. Eliminare Dati (<code>DELETE</code>)</h3>\n<pre><code class=\"language-python\">try:\n    nome_prodotto_da_eliminare = 'Tastiera'\n    cursor.execute(\"DELETE FROM prodotti WHERE nome = ?\", (nome_prodotto_da_eliminare,))\n    conn.commit()\n    print(f\"Prodotto '{nome_prodotto_da_eliminare}' eliminato. Righe modificate: {cursor.rowcount}\")\nexcept sqlite3.Error as e:\n    print(f\"Errore durante DELETE: {e}\")</code></pre>\n\n<h3>7. Chiusura Connessione</h3>\n<pre><code class=\"language-python\">finally:\n    # Assicurati che la connessione venga chiusa anche in caso di errori precedenti\n    if conn:\n        conn.close()\n        print(\"\nConnessione al database chiusa.\")</code></pre>\n<p>Il modulo <code>sqlite3</code> offre un modo potente e standard per gestire dati strutturati direttamente all'interno dei tuoi script Python.</p>",
  "exercise": "<p>Questo esercizio usa un database in memoria (<code>':memory:'</code>).</p>\n<p>1. Importa <code>sqlite3</code>.</p>\n<p>2. Connettiti a un database in memoria e crea un cursore.</p>\n<p>3. Crea una tabella chiamata <code>contatti</code> con le seguenti colonne:</p>\n    <ul>\n        <li><code>id</code>: INTEGER PRIMARY KEY</li>\n        <li><code>nome</code>: TEXT NOT NULL</li>\n        <li><code>email</code>: TEXT UNIQUE</li>\n        <li><code>telefono</code>: TEXT</li>\n    </ul>\n<p>4. Inserisci almeno due contatti nella tabella usando i placeholder <code>?</code> e <code>executemany()</code>.</p>\n<p>5. Esegui una query <code>SELECT</code> per recuperare tutti i contatti dalla tabella.</p>\n<p>6. Usa <code>fetchall()</code> per ottenere i risultati e stampa ogni contatto (ogni tupla) recuperato.</p>\n<p>7. Esegui una query <code>SELECT</code> per recuperare solo il nome e l'email del contatto con un nome specifico (a tua scelta tra quelli inseriti).</p>\n<p>8. Usa <code>fetchone()</code> per ottenere il risultato e stampalo.</p>\n<p>9. Assicurati di fare il <code>commit()</code> dopo l'inserimento e di chiudere la connessione alla fine (usa un blocco <code>try...finally</code> per la chiusura).</p>",
  "defaultCode": "import sqlite3\n\nconn = None # Inizializza a None per il blocco finally\n\ntry:\n    # 2. Connetti e crea cursore\n    conn = sqlite3.connect(':memory:')\n    cursor = conn.cursor()\n    print(\"Connesso al DB in memoria.\")\n\n    # 3. Crea tabella contatti\n    cursor.execute(\"\"\"\n        CREATE TABLE contatti (\n            id INTEGER PRIMARY KEY,\n            nome TEXT NOT NULL,\n            email TEXT UNIQUE,\n            telefono TEXT\n        )\n    \"\"\")\n    conn.commit()\n    print(\"Tabella 'contatti' creata.\")\n\n    # 4. Inserisci contatti con executemany\n    contatti_da_inserire = [\n        ('Mario Rossi', 'mario.rossi@email.com', '123456'),\n        ('Laura Bianchi', 'laura.bianchi@email.it', '789012'),\n        ('Paolo Verdi', 'paolo.verdi@server.net', None) # Telefono opzionale\n    ]\n    cursor.executemany(\"INSERT INTO contatti (nome, email, telefono) VALUES (?, ?, ?)\", contatti_da_inserire)\n    conn.commit() # Commit dopo l'inserimento\n    print(f\"{len(contatti_da_inserire)} contatti inseriti.\")\n\n    # 5. SELECT tutti i contatti\n    print(\"\n--- Tutti i Contatti ---\")\n    cursor.execute(\"SELECT * FROM contatti\")\n    # 6. Fetchall e stampa\n    tutti_contatti = cursor.fetchall()\n    for contatto in tutti_contatti:\n        print(contatto)\n\n    # 7. SELECT nome ed email specifici\n    nome_da_cercare = 'Laura Bianchi'\n    print(f\"\n--- Dettagli per {nome_da_cercare} ---\")\n    cursor.execute(\"SELECT nome, email FROM contatti WHERE nome = ?\", (nome_da_cercare,))\n    # 8. Fetchone e stampa\n    contatto_specifico = cursor.fetchone()\n    if contatto_specifico:\n        print(contatto_specifico)\n    else:\n        print(f\"Contatto '{nome_da_cercare}' non trovato.\")\n\nexcept sqlite3.Error as e:\n    print(f\"Errore SQLite: {e}\")\n\nfinally:\n    # 9. Chiudi connessione\n    if conn:\n        conn.close()\n        print(\"\nConnessione al database chiusa.\")"
}
