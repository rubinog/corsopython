{
  "id": "file_io",
  "title": "Input/Output File: Leggere e Scrivere Dati",
  "explanation": "<h2>Input/Output (I/O) su File: Persistenza dei Dati</h2>\n<p>Finora i dati che abbiamo usato (variabili, liste, ecc.) esistevano solo nella memoria del computer mentre lo script era in esecuzione. Una volta terminato lo script, tutto veniva perso. Per salvare dati in modo permanente (<strong>persistenza</strong>) o per leggere dati da fonti esterne, dobbiamo interagire con i <strong>file</strong>.</p>\n<p><strong>⚠️ Limitazioni nel Browser:</strong> Per motivi di sicurezza, l'accesso diretto al filesystem locale dell'utente da uno script eseguito in un browser (come questo ambiente con Pyodide) è fortemente limitato o impossibile. Non possiamo leggere o scrivere file arbitrari sul tuo computer come farebbe uno script Python standard. Gli esempi che seguono illustrano i concetti, ma useremo un oggetto speciale, <code>io.StringIO</code>, per <em>simulare</em> un file in memoria quando necessario per l'esecuzione pratica qui.</p>\n\n<h2>Aprire un File: La Funzione <code>open()</code></h2>\n<p>Il primo passo per lavorare con un file è aprirlo usando la funzione <code>open()</code>. Questa funzione restituisce un oggetto file (chiamato anche <em>handle</em>) che useremo per leggere o scrivere.</p>\n<p><code>open(percorso_file, modalita)</code></p>\n<ul>\n    <li><code>percorso_file</code>: Una stringa che indica dove si trova il file (es. <code>'dati.txt'</code>, <code>'cartella/mio_file.csv'</code>).</li>\n    <li><code>modalita</code>: Una stringa che specifica come vogliamo interagire con il file. Le modalità più comuni sono:\n        <ul>\n            <li><code>'r'</code>: Lettura (Read). Modalità di default. Causa errore se il file non esiste.</li>\n            <li><code>'w'</code>: Scrittura (Write). Crea un nuovo file o sovrascrive completamente un file esistente.</li>\n            <li><code>'a'</code>: Aggiunta (Append). Scrive alla fine del file senza cancellare il contenuto esistente. Crea il file se non esiste.</li>\n            <li><code>'b'</code>: Modalità binaria (es. <code>'rb'</code>, <code>'wb'</code>). Usata per file non testuali come immagini o eseguibili.</li>\n            <li><code>'+'</code>: Aggiornamento (lettura e scrittura, es. <code>'r+'</code>, <code>'w+'</code>).</li>\n        </ul>\n    </li>\n</ul>\n\n<h2>Il Costrutto <code>with</code>: Gestione Automatica</h2>\n<p>Dopo aver aperto un file, è <strong>fondamentale</strong> chiuderlo quando abbiamo finito, per assicurarsi che tutti i dati siano stati scritti correttamente e per liberare risorse. Dimenticarsi di chiudere i file può causare problemi.</p>\n<p>Il modo migliore e più sicuro per gestire i file in Python è usare il costrutto <code>with</code>. Questo garantisce che il file venga chiuso automaticamente, anche se si verificano errori durante le operazioni.</p>\n<pre><code class=\"language-python\"># Sintassi raccomandata con 'with'\n# try:\n#     with open('mio_file.txt', 'w') as file_oggetto:\n#         # Operazioni di scrittura qui...\n#         file_oggetto.write(\"Prima riga.\n\")\n#         file_oggetto.write(\"Seconda riga.\n\")\n#     # Qui il file è automaticamente chiuso, anche se c'erano errori\n#     print(\"File scritto e chiuso correttamente.\")\n# except IOError as e:\n#     print(f\"Errore durante l'operazione sul file: {e}\")\n</code></pre>\n\n<h2>Leggere da File</h2>\n<p>Una volta aperto un file in modalità lettura (<code>'r'</code>), ci sono diversi modi per leggerne il contenuto:</p>\n<ul>\n    <li><code>file_oggetto.read()</code>: Legge l'intero contenuto del file e lo restituisce come un'unica stringa. Attenzione con file molto grandi, potrebbe consumare molta memoria.</li>\n    <li><code>file_oggetto.readline()</code>: Legge una singola riga dal file (inclusa l'eventuale carattere di newline <code>\n</code> alla fine) e la restituisce come stringa. Ad ogni chiamata successiva, legge la riga seguente. Restituisce una stringa vuota quando si raggiunge la fine del file.</li>\n    <li><code>file_oggetto.readlines()</code>: Legge tutte le righe rimanenti del file e le restituisce come una lista di stringhe, dove ogni stringa rappresenta una riga (inclusi i <code>\n</code>). Attenzione alla memoria con file grandi.</li>\n    <li><strong>Iterare direttamente sull'oggetto file:</strong> Questo è spesso il modo più efficiente e idiomatico per leggere un file riga per riga, specialmente se è grande, perché legge una riga alla volta in memoria.</li>\n</ul>\n<pre><code class=\"language-python\">import io\n\n# Simuliamo un file con più righe\ncontenuto_simulato = \"Riga 1\nRiga 2\nRiga 3\"\nfile_simulato = io.StringIO(contenuto_simulato)\n\nprint(\"--- Lettura con read() ---\")\n# Nota: dopo read(), il 'cursore' è alla fine, quindi altre letture non funzionano\n# contenuto_completo = file_simulato.read()\n# print(contenuto_completo)\n# file_simulato.seek(0) # Riporta il cursore all'inizio per rileggere\n\nprint(\"--- Lettura con readline() ---\")\nfile_simulato.seek(0) # Torna all'inizio\nriga1 = file_simulato.readline()\nprint(f\"Prima riga: '{riga1.strip()}'\") # strip() toglie \n\nriga2 = file_simulato.readline()\nprint(f\"Seconda riga: '{riga2.strip()}'\")\n\nprint(\"--- Lettura con readlines() ---\")\nfile_simulato.seek(0)\ntutte_le_righe = file_simulato.readlines()\nprint(tutte_le_righe) # Lista di stringhe\n\nprint(\"--- Lettura con iterazione (modo preferito) ---\")\nfile_simulato.seek(0)\nfor indice, riga in enumerate(file_simulato):\n    print(f\"Riga {indice + 1}: {riga.strip()}\")\n\nfile_simulato.close() # Chiudiamo il file simulato</code></pre>\n\n<h2>Scrivere su File</h2>\n<p>Aprendo un file in modalità scrittura (<code>'w'</code>) o aggiunta (<code>'a'</code>), puoi scrivere dati:</p>\n<ul>\n    <li><code>file_oggetto.write(stringa)</code>: Scrive la <code>stringa</code> specificata nel file. Non aggiunge automaticamente un ritorno a capo (<code>\n</code>), devi aggiungerlo tu se necessario.</li>\n    <li><code>file_oggetto.writelines(lista_di_stringhe)</code>: Scrive tutti gli elementi della <code>lista_di_stringhe</code> nel file. Anche qui, non aggiunge ritorni a capo tra le stringhe.</li>\n</ul>\n<pre><code class=\"language-python\">import io\n\n# Simuliamo la scrittura su un file (modalità 'w' - sovrascrittura)\noutput_simulato_w = io.StringIO()\n\noutput_simulato_w.write(\"Hello, \")\noutput_simulato_w.write(\"World!\n\") # Aggiungiamo \n manualmente\n\nrighe_da_scrivere = [\"Riga A\n\", \"Riga B\n\", \"Riga C\"]\noutput_simulato_w.writelines(righe_da_scrivere)\n\nprint(\"--- Contenuto scritto (modalità 'w') ---\")\nprint(output_simulato_w.getvalue()) # getvalue() per leggere da StringIO\noutput_simulato_w.close()\n\n# Simuliamo la scrittura in modalità 'a' (append)\noutput_simulato_a = io.StringIO()\noutput_simulato_a.write(\"Contenuto iniziale.\n\") # Scriviamo qualcosa\n\n# Ora aggiungiamo\noutput_simulato_a.write(\"Questa riga viene aggiunta.\n\")\n\nprint(\"\n--- Contenuto scritto (modalità 'a') ---\")\nprint(output_simulato_a.getvalue())\noutput_simulato_a.close()</code></pre>\n<p>Lavorare con i file è essenziale per la maggior parte delle applicazioni reali, permettendo ai programmi di leggere configurazioni, processare dati e salvare risultati.</p>",
  "exercise": "<p>Questo esercizio usa <code>io.StringIO</code> per simulare l'I/O su file.</p>\n<p>1. Crea una lista di stringhe chiamata <code>dati_utente</code>, dove ogni stringa rappresenta una riga di un file CSV (es. <code>\"ID,Nome,Email\n\"</code>, <code>\"1,Mario,mario@mail.com\n\"</code>, <code>\"2,Luisa,luisa@mail.it\n\"</code>). Assicurati di includere il carattere newline <code>\n</code> alla fine di ogni riga tranne forse l'ultima.</p>\n<p>2. Simula la scrittura di queste righe su un file chiamato \"utenti.csv\" usando <code>io.StringIO</code> e il metodo <code>writelines()</code>.</p>\n<p>3. Stampa il contenuto completo scritto nell'oggetto StringIO per verificare.</p>\n<p>4. Ora, simula la rilettura del \"file\" appena creato. Riporta il \"cursore\" dell'oggetto StringIO all'inizio usando <code>seek(0)</code>.</p>\n<p>5. Leggi e stampa il contenuto del file simulato riga per riga usando un ciclo <code>for</code>, rimuovendo eventuali spazi bianchi o newline iniziali/finali da ogni riga prima di stamparla.</p>",
  "defaultCode": "import io\n\n# 1. Lista dati utente (simulazione righe CSV)\ndati_utente = [\n    \"ID,Nome,Email\n\",\n    \"1,Mario,mario@mail.com\n\",\n    \"2,Luisa,luisa@mail.it\n\",\n    \"3,Carlo,carlo@server.org\"\n]\n\n# 2. Simula scrittura su file\nfile_csv_simulato = io.StringIO()\ntry:\n    file_csv_simulato.writelines(dati_utente)\n    print(\"Dati scritti nel file simulato.\")\nexcept Exception as e:\n    print(f\"Errore durante la scrittura simulata: {e}\")\n\n# 3. Stampa contenuto scritto\nprint(\"\n--- Contenuto Scritto nel File Simulato ---\")\ncontenuto_scritto = file_csv_simulato.getvalue()\nprint(contenuto_scritto)\n\n# 4. Riporta cursore all'inizio\nfile_csv_simulato.seek(0)\n\n# 5. Leggi e stampa riga per riga\nprint(\"\n--- Lettura Riga per Riga dal File Simulato ---\")\ntry:\n    for riga in file_csv_simulato:\n        print(riga.strip()) # strip() rimuove spazi e newline\nexcept Exception as e:\n    print(f\"Errore durante la lettura simulata: {e}\")\nfinally:\n    file_csv_simulato.close() # Chiudi sempre l'oggetto StringIO\n    print(\"\nFile simulato chiuso.\")"
}
