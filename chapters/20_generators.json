{
  "id": "generators",
  "title": "Generators: Iteratori Efficienti con `yield`",
  "explanation": "<h2>Generators: Creare Iteratori al Volo</h2>\n<p>I generatori sono un modo speciale e molto efficiente in termini di memoria per creare <strong>iteratori</strong>. Un iteratore è un oggetto che permette di scorrere una sequenza di elementi uno alla volta (come in un ciclo <code>for</code>).</p>\n<p>La differenza chiave tra un generatore e una collezione normale (come una lista) è che il generatore non costruisce e memorizza tutti gli elementi in memoria contemporaneamente. Invece, li produce (li \"genera\") uno alla volta, solo quando richiesto. Questo approccio è chiamato <strong>lazy evaluation</strong> (valutazione pigra).</p>\n\n<h2>Perché Usare i Generatori?</h2>\n<ul>\n    <li><strong>Efficienza di Memoria:</strong> Sono ideali per lavorare con sequenze molto grandi (potenzialmente infinite) che non entrerebbero in memoria se fossero create come liste complete.</li>\n    <li><strong>Efficienza di Calcolo:</strong> Il calcolo per produrre l'elemento successivo avviene solo quando necessario, non tutto in anticipo.</li>\n    <li><strong>Codice più Pulito:</strong> Spesso permettono di scrivere codice più semplice e leggibile per creare sequenze complesse rispetto alla creazione manuale di una classe iteratore.</li>\n</ul>\n\n<h2>Creare Generatori con Funzioni e <code>yield</code></h2>\n<p>Il modo più comune per creare un generatore è definire una funzione che usa la parola chiave <code>yield</code>.</p>\n<p>Quando una funzione contiene <code>yield</code>, chiamarla non esegue immediatamente il codice al suo interno. Invece, restituisce un <strong>oggetto generatore</strong>.</p>\n<p>Ogni volta che si itera sull'oggetto generatore (es. in un ciclo <code>for</code> o chiamando <code>next()</code> su di esso), l'esecuzione della funzione riprende da dove si era interrotta, fino a quando non incontra un'istruzione <code>yield</code>. Il valore specificato da <code>yield</code> viene restituito, e l'esecuzione della funzione viene nuovamente messa in pausa, conservando il suo stato locale.</p>\n<p>Quando la funzione termina (raggiunge la fine o incontra un <code>return</code> senza valore), il generatore solleva un'eccezione <code>StopIteration</code>, segnalando la fine della sequenza.</p>\n<pre><code class=\"language-python\"># Funzione generatore che produce numeri da 0 a n-1\ndef conta_fino_a(n):\n    print(\"[Generatore] Inizio esecuzione\")\n    i = 0\n    while i < n:\n        print(f\"[Generatore] Sto per fare yield di {i}\")\n        yield i # Restituisce i e mette in pausa\n        i += 1\n        print(f\"[Generatore] Esecuzione ripresa, i ora è {i}\")\n    print(\"[Generatore] Fine esecuzione\")\n\n# Chiamare la funzione restituisce un oggetto generatore\ngeneratore_numeri = conta_fino_a(3)\nprint(f\"Tipo dell'oggetto restituito: {type(generatore_numeri)}\")\n\nprint(\"\n--- Iterazione con ciclo for ---\")\n# Il ciclo for gestisce automaticamente la chiamata a next() e StopIteration\nfor numero in generatore_numeri:\n    print(f\"[Ciclo For] Ricevuto: {numero}\")\n\nprint(\"\n--- Iterazione manuale con next() ---\")\n# Creiamo un nuovo generatore\ngeneratore_numeri_2 = conta_fino_a(2)\ntry:\n    print(\"Chiamo next() la prima volta...\")\n    val1 = next(generatore_numeri_2)\n    print(f\"Ricevuto da next(): {val1}\")\n\n    print(\"\nChiamo next() la seconda volta...\")\n    val2 = next(generatore_numeri_2)\n    print(f\"Ricevuto da next(): {val2}\")\n\n    print(\"\nChiamo next() la terza volta (causerà StopIteration)...\")\n    val3 = next(generatore_numeri_2)\nexcept StopIteration:\n    print(\"StopIteration catturata correttamente.\")\n</code></pre>\n<p>Nota come l'esecuzione della funzione generatore si alterna con il codice che la sta iterando.</p>\n\n<h2>Espressioni Generatore: Sintassi Simile alle List Comprehension</h2>\n<p>Puoi creare generatori in modo conciso usando una sintassi simile alle list comprehension, ma con parentesi tonde <code>()</code> invece che quadre <code>[]</code>.</p>\n<p><code>generatore = (espressione for elemento in iterabile if condizione)</code></p>\n<p>Questo crea direttamente un oggetto generatore, senza costruire la lista completa in memoria.</p>\n<pre><code class=\"language-python\"># List comprehension (crea la lista intera in memoria)\nlista_quadrati = [x*x for x in range(1000000)]\n# print(f\"Lista creata (potrebbe essere grande)\")\n\n# Espressione generatore (crea un oggetto generatore, efficiente in memoria)\ngen_quadrati = (x*x for x in range(1000000))\nprint(f\"Tipo dell'espressione generatore: {type(gen_quadrati)}\")\n\n# Possiamo iterare sul generatore\nprint(\"\nPrimi 5 quadrati dal generatore:\")\ncount = 0\nfor q in gen_quadrati:\n    print(q)\n    count += 1\n    if count >= 5:\n        break # Fermiamoci dopo 5 per non stampare troppo</code></pre>\n<p>Le espressioni generatore sono particolarmente utili quando passi una sequenza generata al volo a un'altra funzione (es. <code>sum()</code>, <code>max()</code>, ecc.) senza bisogno di creare una lista intermedia.</p>\n<pre><code class=\"language-python\"># Somma dei quadrati dei numeri pari sotto 100, senza creare lista intermedia\nsomma_quadrati_pari = sum(x*x for x in range(100) if x % 2 == 0)\nprint(f\"\nSomma quadrati pari: {somma_quadrati_pari}\")</code></pre>\n<p>I generatori sono uno strumento fondamentale per scrivere codice Python efficiente e scalabile quando si lavora con sequenze di dati.</p>",
  "exercise": "<p>1. Scrivi una funzione generatore chiamata <code>fibonacci(limite)</code> che generi i numeri della sequenza di Fibonacci (dove ogni numero è la somma dei due precedenti, iniziando con 0 e 1) fino a raggiungere o superare il <code>limite</code> specificato.</p>\n<p>   La sequenza inizia: 0, 1, 1, 2, 3, 5, 8, 13, ...</p>\n<p>2. Crea un generatore chiamando <code>fibonacci(50)</code>.</p>\n<p>3. Usa un ciclo <code>for</code> per iterare sul generatore e stampare ogni numero di Fibonacci generato.</p>\n<p>4. (Opzionale) Usa un'espressione generatore per calcolare la somma di tutti i numeri dispari tra 1 e 1000.</p>",
  "defaultCode": "# 1. Funzione generatore fibonacci\ndef fibonacci(limite):\n    \"\"\"Genera numeri di Fibonacci fino a un limite.\"\"\"\n    a, b = 0, 1 # Primi due numeri della sequenza\n    while a < limite:\n        yield a\n        a, b = b, a + b # Aggiorna i prossimi due numeri\n\n# 2. Crea il generatore\ngen_fib = fibonacci(50)\nprint(f\"Tipo di gen_fib: {type(gen_fib)}\")\n\n# 3. Itera e stampa\nprint(\"\nNumeri di Fibonacci minori di 50:\")\nfor num in gen_fib:\n    print(num)\n\n# 4. (Opzionale) Somma numeri dispari con espressione generatore\nsomma_dispari = sum(n for n in range(1, 1001) if n % 2 != 0)\nprint(f\"\nSomma dei numeri dispari da 1 a 1000: {somma_dispari}\")"
}
