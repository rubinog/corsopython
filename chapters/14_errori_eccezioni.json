{
  "id": "errori_eccezioni",
  "title": "Gestione Errori (try/except)",
  "explanation": "<h2>Gestire gli Imprevisti: Errori ed Eccezioni</h2>\n<p>Durante l'esecuzione di un programma, possono verificarsi errori. Alcuni sono errori di sintassi (SyntaxError), che impediscono al programma persino di iniziare. Altri sono errori che si verificano durante l'esecuzione (runtime errors), chiamati <strong>eccezioni</strong>. Esempi comuni sono tentare di dividere per zero (<code>ZeroDivisionError</code>) o accedere a un indice di lista inesistente (<code>IndexError</code>).</p>\n<p>Se un'eccezione non viene gestita, l'esecuzione del programma si interrompe bruscamente mostrando un messaggio di errore (traceback), il che non è ideale per l'utente finale.</p>\n\n<h2>Il Blocco <code>try...except</code>: Catturare le Eccezioni</h2>\n<p>Python fornisce il blocco <code>try...except</code> per gestire le eccezioni in modo controllato. Metti il codice che *potrebbe* causare un errore nel blocco <code>try</code>. Se si verifica un'eccezione durante l'esecuzione del blocco <code>try</code>, Python salta il resto del codice nel <code>try</code> e cerca un blocco <code>except</code> corrispondente.</p>\n<pre><code class=\"language-python\">try:\n    # Codice potenzialmente problematico\n    numero = int(input(\"Inserisci un numero: \")) # input() non funziona qui, simuliamo\n    # Simuliamo input non numerico per il primo test\n    # numero = int(\"abc\")\n    risultato = 10 / numero\n    print(f\"10 diviso {numero} fa {risultato}\")\n\nexcept ValueError:\n    # Eseguito se int() fallisce (es. input non numerico)\n    print(\"Errore: Devi inserire un numero valido!\")\n\nexcept ZeroDivisionError:\n    # Eseguito se si tenta la divisione per zero\n    print(\"Errore: Non puoi dividere per zero!\")\n\nprint(\"Il programma continua dopo il blocco try...except.\")\n</code></pre>\n<p>Nell'esempio sopra (simulato, dato che <code>input()</code> non funziona qui):</p>\n<ul>\n    <li>Se l'utente inserisse \"abc\", <code>int(\"abc\")</code> solleverebbe un <code>ValueError</code>, e verrebbe eseguito il primo blocco <code>except</code>.</li>\n    <li>Se l'utente inserisse \"0\", <code>10 / 0</code> solleverebbe un <code>ZeroDivisionError</code>, e verrebbe eseguito il secondo blocco <code>except</code>.</li>\n    <li>Se l'utente inserisse \"5\", nessuna eccezione verrebbe sollevata nel <code>try</code>, i blocchi <code>except</code> verrebbero saltati, e il programma continuerebbe normalmente.</li>\n</ul>\n\n<h2>Gestire Tipi Diversi di Eccezioni</h2>\n<p>Puoi avere più blocchi <code>except</code> per gestire tipi specifici di errori in modi diversi. Puoi anche catturare più tipi di eccezioni con un singolo blocco <code>except</code> usando una tupla.</p>\n<pre><code class=\"language-python\">lista = [1, 2, 3]\ndiz = {\"a\": 1}\n\ntry:\n    indice = 5\n    chiave = \"b\"\n    # valore_lista = lista[indice] # Potrebbe causare IndexError\n    valore_diz = diz[chiave]   # Potrebbe causare KeyError\n\nexcept (IndexError, KeyError) as e: # Cattura entrambi i tipi\n    print(f\"Errore di accesso! Indice o chiave non trovati: {e}\")\n    print(f\"Tipo di errore specifico: {type(e).__name__}\")\n\nexcept Exception as e: # Cattura qualsiasi altra eccezione (generico)\n    print(f\"Si è verificato un errore imprevisto: {e}\")\n    print(f\"Tipo di errore: {type(e).__name__}\")\n</code></pre>\n<p><strong>Catturare l'oggetto eccezione (<code>as e</code>):</strong> Aggiungendo <code>as nome_variabile</code> (comunemente <code>as e</code>) al blocco <code>except</code>, puoi accedere all'oggetto eccezione stesso, che spesso contiene informazioni più dettagliate sull'errore.</p>\n<p><strong><code>except Exception as e</code>:</strong> Questo cattura quasi tutti i tipi di eccezioni. È utile come ultima risorsa per gestire errori imprevisti, ma usalo con cautela. È generalmente meglio catturare eccezioni specifiche quando possibile, per non mascherare errori che non ti aspetti.</p>\n\n<h2>Le Clausole <code>else</code> e <code>finally</code></h2>\n<p>Il blocco <code>try...except</code> può essere esteso con due clausole opzionali:</p>\n<ul>\n    <li><strong><code>else</code>:</strong> Il blocco <code>else</code> viene eseguito <strong>solo se</strong> nessuna eccezione si è verificata nel blocco <code>try</code>. È utile per il codice che deve essere eseguito solo in caso di successo del <code>try</code>.</li>\n    <li><strong><code>finally</code>:</strong> Il blocco <code>finally</code> viene eseguito <strong>sempre</strong>, indipendentemente dal fatto che si sia verificata un'eccezione o meno, e anche se c'è un <code>return</code>, <code>break</code> o <code>continue</code> nel <code>try</code> o <code>except</code>. È ideale per operazioni di pulizia che devono avvenire comunque (es. chiudere un file o una connessione di rete).</li>\n</ul>\n<pre><code class=\"language-python\">try:\n    # Simuliamo l'apertura e l'elaborazione di un file\n    print(\"Apro il file (simulato)...\")\n    # dati = file_oggetto.read()\n    # risultato = int(dati) # Potrebbe causare ValueError\n    risultato = 10 # Simuliamo successo\n    # risultato = int(\"abc\") # Simuliamo fallimento\n\nexcept ValueError:\n    print(\"Errore: Il contenuto del file non è un numero valido.\")\n\nelse:\n    # Eseguito solo se il try ha successo\n    print(f\"Elaborazione completata con successo. Risultato: {risultato}\")\n\nfinally:\n    # Eseguito sempre\n    print(\"Chiudo il file (simulato).\")\n</code></pre>\n<p>La gestione delle eccezioni è cruciale per scrivere programmi robusti che possono gestire situazioni impreviste senza interrompersi.</p>",
  "exercise": "<p>1. Scrivi una funzione <code>dividi_elementi(lista, divisore)</code> che:</p>\n    <ul>\n        <li>Accetta una lista di numeri e un divisore.</li>\n        <li>Crea una nuova lista contenente il risultato della divisione di ogni elemento della lista originale per il <code>divisore</code>.</li>\n        <li>Usa un blocco <code>try...except</code> all'interno del ciclo per gestire due possibili errori per ogni elemento:\n            <ul>\n                <li><code>ZeroDivisionError</code>: Se il <code>divisore</code> è 0. Stampa un messaggio di errore specifico.</li>\n                <li><code>TypeError</code>: Se un elemento nella lista non è un numero. Stampa un messaggio indicando l'elemento problematico.</li>\n            </ul>\n        </li>\n        <li>La funzione dovrebbe restituire la nuova lista con i risultati validi.</li>\n    </ul>\n<p>2. Chiama la funzione con <code>lista = [10, 20, 'trenta', 40, 0]</code> e <code>divisore = 5</code>. Stampa la lista restituita.</p>\n<p>3. Chiama la funzione con la stessa lista ma con <code>divisore = 0</code>. Stampa la lista restituita (dovrebbe essere vuota o contenere meno elementi).</p>",
  "defaultCode": "def dividi_elementi(lista, divisore):\n    \"\"\"Divide gli elementi numerici di una lista per un divisore, gestendo errori.\"\"\"\n    risultati = []\n    for elemento in lista:\n        try:\n            # Tenta la divisione\n            risultato_divisione = elemento / divisore\n            risultati.append(risultato_divisione)\n        except ZeroDivisionError:\n            print(f\"Errore: Impossibile dividere {elemento} per zero. Salto.\")\n            # Puoi decidere di interrompere tutto il ciclo qui con 'break' se preferisci\n        except TypeError:\n            print(f\"Errore: L'elemento '{elemento}' non è un numero valido. Salto.\")\n        except Exception as e:\n            # Cattura altri errori imprevisti per quell'elemento\n            print(f\"Errore imprevisto con l'elemento {elemento}: {e}. Salto.\")\n    return risultati\n\n# Test 1: Divisore valido, lista mista\nlista_input = [10, 20, 'trenta', 40, 0, 50.5]\ndivisore_valido = 5\nprint(f\"Divisione di {lista_input} per {divisore_valido}:\")\noutput1 = dividi_elementi(lista_input, divisore_valido)\nprint(f\"Risultati validi: {output1}\")\n\nprint(\"\n\" + \"-\"*20 + \"\n\")\n\n# Test 2: Divisore zero\ndivisore_zero = 0\nprint(f\"Divisione di {lista_input} per {divisore_zero}:\")\noutput2 = dividi_elementi(lista_input, divisore_zero)\nprint(f\"Risultati validi: {output2}\")"
}
