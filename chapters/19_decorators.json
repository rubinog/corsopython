{
  "id": "decorators",
  "title": "Decorators: Modificare Funzioni Dinamicamente",
  "explanation": "<h2>Decorators: Aggiungere Funzionalità alle Funzioni</h2>\n<p>I decorators sono una caratteristica potente e distintiva di Python che permette di modificare o estendere il comportamento di funzioni o metodi in modo pulito e riutilizzabile. Sono un esempio di metaprogrammazione (codice che manipola altro codice).</p>\n<p>In sostanza, un decorator è una funzione che prende un'altra funzione come argomento, aggiunge qualche funzionalità \"intorno\" ad essa (prima e/o dopo la sua esecuzione) e restituisce la funzione modificata (o una nuova funzione wrapper).</p>\n\n<h2>La Sintassi <code>@</code></h2>\n<p>La sintassi più comune per applicare un decorator a una funzione usa il simbolo <code>@</code> seguito dal nome del decorator, posto sulla riga precedente la definizione della funzione da decorare.</p>\n<pre><code class=\"language-python\">@mio_decorator\ndef mia_funzione():\n    # ... corpo della funzione ...\n    pass</code></pre>\n<p>Questa sintassi è una scorciatoia per:</p>\n<pre><code class=\"language-python\">def mia_funzione():\n    # ... corpo della funzione ...\n    pass\nmia_funzione = mio_decorator(mia_funzione)</code></pre>\n<p>Capire questa equivalenza è fondamentale per comprendere come funzionano i decorators.</p>\n\n<h2>Esempio Semplice: Un Decorator che Stampa Messaggi</h2>\n<p>Creiamo un decorator che stampa un messaggio prima e dopo l'esecuzione della funzione decorata.</p>\n<pre><code class=\"language-python\"># 1. Definiamo la funzione decorator\ndef semplice_decorator(func): # Accetta la funzione originale come argomento\n    # 2. Definiamo una funzione interna 'wrapper'\n    # Questa funzione sostituirà l'originale\n    def wrapper():\n        print(\"--- Qualcosa PRIMA della chiamata --- \")\n        func() # 3. Chiamiamo la funzione originale\n        print(\"--- Qualcosa DOPO la chiamata --- \")\n    # 4. Il decorator restituisce la funzione wrapper\n    return wrapper\n\n# 5. Applichiamo il decorator alla nostra funzione\n@semplice_decorator\ndef saluta():\n    print(\"Ciao! Sono la funzione 'saluta'.\")\n\n# 6. Chiamiamo la funzione decorata\nprint(\"Sto per chiamare saluta()...\")\nsaluta()\nprint(\"...chiamata a saluta() terminata.\")</code></pre>\n<p>Quando chiamiamo <code>saluta()</code>, in realtà stiamo chiamando la funzione <code>wrapper</code> restituita da <code>semplice_decorator</code>. La <code>wrapper</code> esegue il codice aggiuntivo e chiama la funzione <code>saluta</code> originale al suo interno.</p>\n\n<h2>Decorators per Funzioni con Argomenti e Valori di Ritorno</h2>\n<p>Se la funzione originale accetta argomenti o restituisce un valore, la funzione <code>wrapper</code> deve essere in grado di gestirli. Usiamo <code>*args</code> e <code>**kwargs</code> nella definizione della <code>wrapper</code> per accettare qualsiasi argomento e passarli alla funzione originale. Dobbiamo anche catturare e restituire il valore restituito dalla funzione originale.</p>\n<pre><code class=\"language-python\">import time\n\ndef log_tempo_esecuzione(func):\n    def wrapper(*args, **kwargs): # Accetta qualsiasi argomento\n        start_time = time.time()\n        print(f\"[LOG] Chiamata a '{func.__name__}' con args={args}, kwargs={kwargs}\")\n        \n        # Chiama la funzione originale e cattura il risultato\n        risultato = func(*args, **kwargs) \n        \n        end_time = time.time()\n        tempo_trascorso = end_time - start_time\n        print(f\"[LOG] '{func.__name__}' ha restituito '{risultato}' in {tempo_trascorso:.4f} sec\")\n        \n        # Restituisce il risultato originale\n        return risultato \n    return wrapper\n\n@log_tempo_esecuzione\ndef somma_lenta(a, b, attesa=0.1):\n    \"\"\"Somma due numeri dopo una breve attesa.\"\"\"\n    # Simuliamo lavoro\n    start_wait = time.time()\n    while time.time() - start_wait < attesa:\n        pass\n    return a + b\n\n# Chiamiamo la funzione decorata\nris1 = somma_lenta(5, 3)\nprint(f\"Risultato finale 1: {ris1}\")\n\nris2 = somma_lenta(10, 20, attesa=0.2)\nprint(f\"Risultato finale 2: {ris2}\")</code></pre>\n<p>Nota come la <code>wrapper</code> ora gestisce <code>*args</code>, <code>**kwargs</code> e il valore di ritorno.</p>\n\n<h2>Casi d'Uso Comuni dei Decorators</h2>\n<ul>\n    <li><strong>Logging:</strong> Registrare informazioni sulle chiamate alle funzioni (argomenti, tempi, risultati).</li>\n    <li><strong>Controllo Accessi/Autenticazione:</strong> Verificare se un utente ha i permessi per eseguire una funzione (comune nei framework web).</li>\n    <li><strong>Caching/Memoization:</strong> Memorizzare i risultati di funzioni costose per evitare di ricalcolarli con gli stessi input.</li>\n    <li><strong>Misurazione Performance:</strong> Calcolare il tempo di esecuzione delle funzioni.</li>\n    <li><strong>Validazione Input:</strong> Controllare la validità degli argomenti prima di eseguire la funzione.</li>\n    <li><strong>Modifica del Comportamento:</strong> Aggiungere tentativi multipli (retry) in caso di fallimento, ecc.</li>\n</ul>\n<p>I decorators sono uno strumento avanzato ma estremamente utile per scrivere codice Python più pulito, modulare e potente, separando le preoccupazioni trasversali (come il logging) dalla logica principale della funzione.</p>",
  "exercise": "<p>1. Crea un decorator chiamato <code>solo_positivi</code>.</p>\n<p>2. Questo decorator deve funzionare su funzioni che accettano un numero qualsiasi di argomenti numerici.</p>\n<p>3. All'interno della funzione <code>wrapper</code> del decorator, prima di chiamare la funzione originale, controlla se <strong>tutti</strong> gli argomenti posizionali (<code>*args</code>) passati sono maggiori o uguali a zero.</p>\n<p>4. Se tutti gli argomenti sono non negativi, chiama la funzione originale e restituisci il suo risultato.</p>\n<p>5. Se anche solo un argomento è negativo, non chiamare la funzione originale, stampa un messaggio di errore (es. \"Errore: tutti gli argomenti devono essere non negativi!\") e restituisci <code>None</code>.</p>\n<p>6. Applica questo decorator a una funzione semplice, ad esempio <code>moltiplica_numeri(*numeri)</code> che restituisce il prodotto di tutti i numeri passati.</p>\n<p>7. Testa la funzione decorata sia con numeri positivi che con almeno un numero negativo.</p>",
  "defaultCode": "# 1. Definisci il decorator solo_positivi\ndef solo_positivi(func):\n    # 2. Definisci la wrapper che accetta *args e **kwargs\n    def wrapper(*args, **kwargs):\n        # 3. Controlla se tutti gli argomenti posizionali sono >= 0\n        argomenti_validi = True\n        for arg in args:\n            # Assicurati che sia un numero prima di confrontare\n            if isinstance(arg, (int, float)) and arg < 0:\n                argomenti_validi = False\n                break # Basta un negativo per invalidare\n            # Potresti aggiungere un controllo per tipi non numerici se necessario\n        \n        # 4. Se validi, chiama la funzione originale\n        if argomenti_validi:\n            print(f\"[Decorator] Argomenti validi, chiamo {func.__name__}\")\n            return func(*args, **kwargs)\n        # 5. Altrimenti, stampa errore e restituisci None\n        else:\n            print(f\"[Decorator] Errore: tutti gli argomenti numerici posizionali devono essere >= 0!\")\n            return None\n    return wrapper\n\n# 6. Funzione da decorare\n@solo_positivi\ndef moltiplica_numeri(*numeri):\n    \"\"\"Moltiplica tutti i numeri passati come argomenti.\"\"\"\n    if not numeri: # Se non ci sono numeri, il prodotto è 1 (elemento neutro)\n        return 1 \n    prodotto = 1\n    for num in numeri:\n        # Assumiamo che il decorator abbia già filtrato, ma un controllo extra non fa male\n        if isinstance(num, (int, float)):\n             prodotto *= num\n    return prodotto\n\n# 7. Testa la funzione decorata\nprint(\"--- Test con numeri positivi ---\")\nrisultato1 = moltiplica_numeri(2, 3, 4)\nprint(f\"Risultato 1: {risultato1}\")\n\nprint(\"\n--- Test con un numero negativo ---\")\nrisultato2 = moltiplica_numeri(2, -3, 4)\nprint(f\"Risultato 2: {risultato2}\")\n\nprint(\"\n--- Test senza argomenti ---\")\nrisultato3 = moltiplica_numeri()\nprint(f\"Risultato 3: {risultato3}\")"
}
