{
  "id": "args_kwargs_scope",
  "title": "Argomenti Funzioni e Scope",
  "explanation": "<h2>Flessibilità nelle Funzioni: *args, **kwargs e Scope</h2>\n<p>Abbiamo visto come definire funzioni con parametri posizionali, keyword e di default. Python offre ancora più flessibilità con <code>*args</code> e <code>**kwargs</code>, e introduce il concetto importante di <strong>scope</strong> (ambito) delle variabili.</p>\n\n<h2>Argomenti Posizionali Variabili: <code>*args</code></h2>\n<p>A volte vuoi che una funzione possa accettare un numero qualsiasi di argomenti posizionali, senza doverli definire tutti in anticipo. Puoi farlo usando la sintassi <code>*args</code> (il nome <code>args</code> è una convenzione, ma l'asterisco <code>*</code> è fondamentale).</p>\n<p>Python raccoglierà tutti gli argomenti posizionali extra passati alla funzione in una <strong>tupla</strong> chiamata <code>args</code>.</p>\n<pre><code class=\"language-python\"># Funzione che somma un numero arbitrario di argomenti\ndef somma_tutto(*numeri):\n    print(f\"Tipo di 'numeri': {type(numeri)}\") # Mostra che è una tupla\n    totale = 0\n    for num in numeri:\n        totale += num\n    return totale\n\nrisultato1 = somma_tutto(1, 2, 3)\nprint(f\"Somma(1, 2, 3): {risultato1}\") # Output: 6\n\nrisultato2 = somma_tutto(10, 20, 30, 40, 50)\nprint(f\"Somma(10, 20, 30, 40, 50): {risultato2}\") # Output: 150\n\nrisultato3 = somma_tutto() # Funziona anche senza argomenti\nprint(f\"Somma(): {risultato3}\") # Output: 0</code></pre>\n<p><code>*args</code> deve venire dopo i normali parametri posizionali e di default.</p>\n\n<h2>Argomenti Keyword Variabili: <code>**kwargs</code></h2>\n<p>Similmente, puoi permettere a una funzione di accettare un numero qualsiasi di argomenti keyword non definiti esplicitamente usando la sintassi <code>**kwargs</code> (anche qui, <code>kwargs</code> è una convenzione, i due asterischi <code>**</code> sono importanti).</p>\n<p>Python raccoglierà tutti gli argomenti keyword extra in un <strong>dizionario</strong> chiamato <code>kwargs</code>, dove le chiavi sono i nomi dei parametri passati e i valori sono i valori corrispondenti.</p>\n<pre><code class=\"language-python\"># Funzione che stampa informazioni passate come keyword arguments\ndef stampa_info_utente(id_utente, **dettagli):\n    print(f\"ID Utente: {id_utente}\")\n    print(f\"Tipo di 'dettagli': {type(dettagli)}\") # Mostra che è un dizionario\n    print(\"Dettagli aggiuntivi:\")\n    if dettagli:\n        for chiave, valore in dettagli.items():\n            print(f\"- {chiave.capitalize()}: {valore}\")\n    else:\n        print(\"(Nessuno)\")\n\nstampa_info_utente(101, nome=\"Alice\", eta=30, citta=\"Roma\")\nprint(\"---\")\nstampa_info_utente(102, nome=\"Bob\") # Funziona anche con meno dettagli\nprint(\"---\")\nstampa_info_utente(103) # Funziona senza dettagli extra</code></pre>\n<p><code>**kwargs</code> deve essere l'ultimo parametro nella definizione della funzione, dopo i parametri normali, di default e <code>*args</code>.</p>\n<p><strong>Ordine Completo dei Parametri:</strong> Se li usi tutti, l'ordine deve essere: parametri posizionali normali, parametri di default, <code>*args</code>, <code>**kwargs</code>.</p>\n<pre><code class=\"language-python\">def funzione_completa(a, b, c='default', *args, **kwargs):\n    print(f\"a={a}, b={b}, c={c}\")\n    print(f\"args={args}\")\n    print(f\"kwargs={kwargs}\")\n\nfunzione_completa(1, 2, 'valore_c', 10, 20, x=100, y=200)</code></pre>\n\n<h2>Scope (Ambito) delle Variabili: Dove Vive una Variabile?</h2>\n<p>Lo <strong>scope</strong> di una variabile determina dove nel codice quella variabile è accessibile e riconosciuta.</p>\n<ul>\n    <li><strong>Scope Locale (Local Scope):</strong> Variabili definite <em>all'interno</em> di una funzione (inclusi i parametri) esistono solo all'interno di quella funzione. Non sono accessibili dall'esterno. Ogni volta che la funzione viene chiamata, viene creato un nuovo scope locale.</li>\n    <li><strong>Scope Globale (Global Scope):</strong> Variabili definite <em>al di fuori</em> di tutte le funzioni, al livello principale dello script, hanno scope globale. Sono accessibili da qualsiasi punto dello script, incluse le funzioni (in lettura).</li>\n    <li><strong>Scope Enclosing (Non-local Scope):</strong> Riguarda le funzioni nidificate (funzioni definite dentro altre funzioni). Una funzione interna può accedere alle variabili della funzione esterna che la contiene.</li>\n    <li><strong>Scope Built-in:</strong> Contiene i nomi predefiniti di Python (es. <code>print</code>, <code>len</code>, <code>str</code>, <code>list</code>, tipi di eccezioni come <code>ValueError</code>).</li>\n</ul>\n<p>Python cerca una variabile seguendo l'ordine: Locale -> Enclosing -> Globale -> Built-in (regola LEGB).</p>\n<pre><code class=\"language-python\">x_globale = 100 # Scope Globale\n\ndef mia_funzione(parametro):\n    y_locale = 20 # Scope Locale\n    print(f\"Dentro funzione: x_globale = {x_globale}\") # Legge globale\n    print(f\"Dentro funzione: y_locale = {y_locale}\")\n    print(f\"Dentro funzione: parametro = {parametro}\")\n\nmia_funzione(5) # Passa 5 come argomento per 'parametro'\n\nprint(f\"\nFuori funzione: x_globale = {x_globale}\")\n# print(f\"Fuori funzione: y_locale = {y_locale}\") # -> NameError: y_locale non è definita qui\n# print(f\"Fuori funzione: parametro = {parametro}\") # -> NameError: parametro non è definito qui</code></pre>\n\n<h3>Modificare Variabili Globali: La Parola Chiave <code>global</code></h3>\n<p>Di default, se assegni un valore a una variabile all'interno di una funzione, Python crea una nuova variabile locale con quel nome, anche se esiste già una variabile globale con lo stesso nome. Per modificare esplicitamente una variabile globale dall'interno di una funzione, devi usare la parola chiave <code>global</code>.</p>\n<pre><code class=\"language-python\">contatore_globale = 0\n\ndef incrementa_contatore():\n    # Senza 'global', questo creerebbe un 'contatore_globale' locale\n    # contatore_globale += 1 # -> UnboundLocalError\n\n    global contatore_globale # Dichiara che vogliamo usare la variabile globale\n    contatore_globale += 1\n    print(f\"Dentro funzione, contatore = {contatore_globale}\")\n\nprint(f\"Prima: {contatore_globale}\")\nincrementa_contatore()\nincrementa_contatore()\nprint(f\"Dopo: {contatore_globale}\")</code></pre>\n<p>L'uso di <code>global</code> è generalmente sconsigliato se non strettamente necessario, perché può rendere più difficile seguire il flusso dei dati nel programma. Spesso è meglio che le funzioni ricevano dati come parametri e restituiscano risultati con <code>return</code>.</p>\n<p>Comprendere <code>*args</code>, <code>**kwargs</code> e lo scope è fondamentale per scrivere funzioni flessibili e gestire correttamente le variabili nei tuoi programmi.</p>",
  "exercise": "<p>1. Definisci una funzione <code>crea_profilo(nome, eta, *interessi, **contatti)</code> che:</p>\n    <ul>\n        <li>Accetta un <code>nome</code> e un'<code>eta</code> obbligatori.</li>\n        <li>Accetta un numero variabile di <code>interessi</code> (stringhe) usando <code>*args</code>.</li>\n        <li>Accetta un numero variabile di <code>contatti</code> (es. email, telefono, social) usando <code>**kwargs</code>.</li>\n        <li>Stampa il nome e l'età.</li>\n        <li>Stampa la lista degli interessi.</li>\n        <li>Stampa il dizionario dei contatti.</li>\n    </ul>\n<p>2. Chiama la funzione <code>crea_profilo</code> con dati a tua scelta, includendo alcuni interessi e alcuni contatti.</p>\n<p>3. Definisci una variabile globale <code>stato_app = \"Inizializzazione\"</code>.</p>\n<p>4. Definisci una funzione <code>aggiorna_stato(nuovo_stato)</code> che usa la parola chiave <code>global</code> per modificare la variabile <code>stato_app</code> con il <code>nuovo_stato</code> passato come argomento.</p>\n<p>5. Stampa il valore iniziale di <code>stato_app</code>.</p>\n<p>6. Chiama <code>aggiorna_stato(\"Pronto\")</code>.</p>\n<p>7. Stampa il nuovo valore di <code>stato_app</code>.</p>",
  "defaultCode": "# 1. Definisci la funzione crea_profilo\ndef crea_profilo(nome, eta, *interessi, **contatti):\n    print(f\"--- Profilo Utente ---\")\n    print(f\"Nome: {nome}\")\n    print(f\"Età: {eta}\")\n    \n    print(\"\nInteressi:\")\n    if interessi:\n        for interesse in interessi:\n            print(f\"- {interesse}\")\n    else:\n        print(\"(Nessuno specificato)\")\n        \n    print(\"\nContatti:\")\n    if contatti:\n        for tipo_contatto, valore_contatto in contatti.items():\n            print(f\"- {tipo_contatto.capitalize()}: {valore_contatto}\")\n    else:\n        print(\"(Nessuno specificato)\")\n    print(\"----------------------\n\")\n\n# 2. Chiama crea_profilo\ncrea_profilo(\"Elena\", 28, \"Lettura\", \"Viaggi\", \"Fotografia\", \n             email=\"elena@example.com\", linkedin=\"/in/elena\", twitter=\"@elena_tweets\")\n\ncrea_profilo(\"Davide\", 40, email=\"davide@mail.org\") # Senza interessi, con un solo contatto\n\n# 3. Variabile globale\nstato_app = \"Inizializzazione\"\n\n# 4. Funzione per aggiornare stato globale\ndef aggiorna_stato(nuovo_stato):\n    global stato_app\n    print(f\"Aggiornamento stato da '{stato_app}' a '{nuovo_stato}'...\")\n    stato_app = nuovo_stato\n\n# 5. Stampa stato iniziale\nprint(f\"Stato iniziale app: {stato_app}\")\n\n# 6. Chiama aggiorna_stato\naggiorna_stato(\"Pronto\")\n\n# 7. Stampa stato finale\nprint(f\"Stato finale app: {stato_app}\")"
}
