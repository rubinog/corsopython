{
  "id": "stringhe_manipolazione",
  "title": "Manipolazione Stringhe: Lavorare con il Testo",
  "explanation": "<h2>Stringhe: Sequenze Immutabili di Caratteri</h2>\n<p>Le stringhe (<code>str</code>) sono uno dei tipi di dati più comuni. Rappresentano sequenze di caratteri (testo). Come le tuple, le stringhe sono <strong>immutabili</strong>: non puoi modificare una stringa esistente; ogni operazione che sembra modificarla, in realtà ne crea una nuova.</p>\n\n<h2>Operazioni Base: Concatenazione e Ripetizione</h2>\n<p>Puoi combinare stringhe usando <code>+</code> (concatenazione) e ripeterle usando <code>*</code>.</p>\n<pre><code class=\"language-python\">str1 = \"Ciao\"\nstr2 = \" Mondo\"\nspazio = \" \"\n\nsaluto_completo = str1 + spazio + str2 + \"!\"\nprint(saluto_completo) # Output: Ciao Mondo!\n\nripetizione = \"Eco... \" * 3\nprint(ripetizione) # Output: Eco... Eco... Eco...</code></pre>\n\n<h2>Accesso e Slicing: Estrarre Parti di Stringhe</h2>\n<p>Funzionano esattamente come per le liste e le tuple, permettendoti di accedere a singoli caratteri o sotto-stringhe.</p>\n<pre><code class=\"language-python\">testo = \"Python è Fantastico\"\n\n# Indicizzazione\nprimo_carattere = testo[0]\nprint(f\"Primo carattere: {primo_carattere}\") # Output: P\n\nultimo_carattere = testo[-1]\nprint(f\"Ultimo carattere: {ultimo_carattere}\") # Output: o\n\n# Slicing\nprima_parola = testo[0:6] # o testo[:6]\nprint(f\"Prima parola: {prima_parola}\") # Output: Python\n\nparte_centrale = testo[7:9]\nprint(f\"Parte centrale: {parte_centrale}\") # Output: è\n\n# Dall'indice 10 alla fine\ndalla_fine = testo[10:]\nprint(f\"Dalla fine: {dalla_fine}\") # Output: Fantastico\n\n# Invertire la stringa\ntesto_invertito = testo[::-1]\nprint(f\"Testo invertito: {testo_invertito}\")</code></pre>\n<p>Ricorda: non puoi fare <code>testo[0] = 'J'</code> perché le stringhe sono immutabili.</p>\n\n<h2>Metodi delle Stringhe: Trasformare e Analizzare</h2>\n<p>Python offre moltissimi metodi utili per lavorare con le stringhe. Questi metodi <strong>non modificano la stringa originale</strong>, ma ne restituiscono una nuova modificata.</p>\n<ul>\n    <li><strong>Cambiare Maiuscole/Minuscole:</strong>\n        <ul>\n            <li><code>lower()</code>: Converte tutto in minuscolo.</li>\n            <li><code>upper()</code>: Converte tutto in maiuscolo.</li>\n            <li><code>capitalize()</code>: Rende maiuscolo solo il primo carattere.</li>\n            <li><code>title()</code>: Rende maiuscola la prima lettera di ogni parola.</li>\n            <li><code>swapcase()</code>: Inverte maiuscole e minuscole.</li>\n        </ul>\n        <pre><code class=\"language-python\">messaggio = \"pYtHoN è BeLlO\"\nprint(f\"lower(): {messaggio.lower()}\")\nprint(f\"upper(): {messaggio.upper()}\")\nprint(f\"capitalize(): {messaggio.capitalize()}\")\nprint(f\"title(): {messaggio.title()}\")\nprint(f\"swapcase(): {messaggio.swapcase()}\")</code></pre>\n    </li>\n    <li><strong>Rimuovere Spazi Bianchi:</strong>\n        <ul>\n            <li><code>strip()</code>: Rimuove spazi (o altri caratteri specificati) dall'inizio e dalla fine.</li>\n            <li><code>lstrip()</code>: Rimuove spazi dall'inizio (left).</li>\n            <li><code>rstrip()</code>: Rimuove spazi dalla fine (right).</li>\n        </ul>\n        <pre><code class=\"language-python\">testo_spazi = \"   Ciao Mondo   \"\nprint(f\"strip(): '{testo_spazi.strip()}'\")\nprint(f\"lstrip(): '{testo_spazi.lstrip()}'\")\nprint(f\"rstrip(): '{testo_spazi.rstrip()}'\")\n\n# Rimuovere altri caratteri\ntesto_punti = \"...Ciao!!!\"\nprint(f\"strip('.'): '{testo_punti.strip('.')}'\") # Rimuove solo i punti iniziali/finali\nprint(f\"strip('.!'): '{testo_punti.strip('.!')}'\") # Rimuove punti o esclamativi</code></pre>\n    </li>\n    <li><strong>Cercare e Sostituire:</strong>\n        <ul>\n            <li><code>find(sub)</code>: Restituisce l'indice della prima occorrenza della sotto-stringa <code>sub</code> (o -1 se non trovata).</li>\n            <li><code>index(sub)</code>: Simile a <code>find()</code>, ma causa <code>ValueError</code> se <code>sub</code> non è trovata.</li>\n            <li><code>replace(old, new, [count])</code>: Sostituisce tutte le occorrenze di <code>old</code> con <code>new</code> (o al massimo <code>count</code> occorrenze se specificato).</li>\n            <li><code>count(sub)</code>: Conta quante volte <code>sub</code> appare nella stringa.</li>\n        </ul>\n        <pre><code class=\"language-python\">frase = \"Python è un linguaggio, Python è versatile.\"\nprint(f\"find('Python'): {frase.find('Python')}\") # Output: 0\nprint(f\"find('Java'): {frase.find('Java')}\") # Output: -1\n# print(f\"index('Java'): {frase.index('Java')}\") # -> ValueError\n\nprint(f\"replace('Python', 'Java'): {frase.replace('Python', 'Java')}\")\nprint(f\"replace('Python', 'Java', 1): {frase.replace('Python', 'Java', 1)}\")\nprint(f\"count('è'): {frase.count('è')}\")</code></pre>\n    </li>\n    <li><strong>Dividere e Unire:</strong>\n        <ul>\n            <li><code>split(sep=None)</code>: Divide la stringa in una lista di sotto-stringhe usando <code>sep</code> come separatore. Se <code>sep</code> non è specificato o è <code>None</code>, divide in base agli spazi bianchi (gestendo anche spazi multipli).</li>\n            <li><code>join(iterable)</code>: Unisce gli elementi di un iterabile (es. lista di stringhe) in un'unica stringa, usando la stringa su cui viene chiamato il metodo come separatore.</li>\n        </ul>\n        <pre><code class=\"language-python\">elementi = \"mela,banana,arancia\"\nlista_frutta = elementi.split(',')\nprint(f\"split(','): {lista_frutta}\")\n\nparole = \"Questa è una frase\"\nlista_parole = parole.split()\nprint(f\"split(): {lista_parole}\")\n\nseparatore = \" - \"\nstringa_unita = separatore.join(lista_frutta)\nprint(f\"join(): {stringa_unita}\") # Output: mela - banana - arancia</code></pre>\n    </li>\n    <li><strong>Controlli Booleani:</strong>\n        <ul>\n            <li><code>startswith(prefix)</code>: Restituisce <code>True</code> se la stringa inizia con <code>prefix</code>.</li>\n            <li><code>endswith(suffix)</code>: Restituisce <code>True</code> se la stringa finisce con <code>suffix</code>.</li>\n            <li><code>isdigit()</code>: <code>True</code> se tutti i caratteri sono cifre.</li>\n            <li><code>isalpha()</code>: <code>True</code> se tutti i caratteri sono lettere.</li>\n            <li><code>isalnum()</code>: <code>True</code> se tutti i caratteri sono lettere o numeri.</li>\n            <li><code>islower()</code> / <code>isupper()</code>: <code>True</code> se tutti i caratteri sono minuscoli/maiuscoli.</li>\n            <li><code>isspace()</code>: <code>True</code> se tutti i caratteri sono spazi bianchi.</li>\n        </ul>\n        <pre><code class=\"language-python\">filename = \"documento.txt\"\nprint(f\"startswith('doc'): {filename.startswith('doc')}\")\nprint(f\"endswith('.pdf'): {filename.endswith('.pdf')}\")\n\nnumero_str = \"12345\"\nprint(f\"'{numero_str}' isdigit()? {numero_str.isdigit()}\")\n\ntesto_alpha = \"SoloLettere\"\nprint(f\"'{testo_alpha}' isalpha()? {testo_alpha.isalpha()}\")</code></pre>\n    </li>\n</ul>\n\n<h2>Formattazione delle Stringhe: f-strings</h2>\n<p>Come già accennato, le f-string (formattate) sono il modo moderno e preferito per inserire valori di variabili o risultati di espressioni all'interno di stringhe.</p>\n<pre><code class=\"language-python\">nome = \"Carlo\"\neta = 42\nprezzo = 19.95\n\nmessaggio = f\"L'utente {nome} (età: {eta}) ha acquistato un item a {prezzo:.2f} euro.\"\n# Nota: :.2f formatta il float per avere sempre 2 cifre decimali\nprint(messaggio)\n\n# Puoi includere calcoli ed espressioni\nquantita = 3\ntotale = prezzo * quantita\nprint(f\"{quantita} items costano in totale {totale:.2f} euro (IVA inclusa: {totale * 1.22:.2f})\")</code></pre>\n<p>Le stringhe sono onnipresenti in programmazione e padroneggiare questi metodi ti renderà molto più efficiente nel manipolare dati testuali.</p>",
  "exercise": "<p>1. Crea una stringa <code>email = \"utente.esempio@dominio.com \"</code> (nota lo spazio finale).</p>\n<p>2. Rimuovi eventuali spazi bianchi iniziali o finali dalla stringa <code>email</code>.</p>\n<p>3. Verifica se l'email (pulita) finisce con \".com\" e stampa il risultato (<code>True</code>/<code>False</code>).</p>\n<p>4. Trova l'indice del carattere \"@\" nell'email.</p>\n<p>5. Usando lo slicing e l'indice trovato, estrai il nome utente (la parte prima della \"@\") e il dominio (la parte dopo la \"@\").</p>\n<p>6. Stampa il nome utente e il dominio separatamente.</p>\n<p>7. Sostituisci \"dominio.com\" con \"nuovodominio.net\" nell'email originale e stampa la nuova email.</p>",
  "defaultCode": "# 1. Stringa email iniziale\nemail = \"utente.esempio@dominio.com \"\nprint(f\"Email originale: '{email}'\")\n\n# 2. Rimuovi spazi\nemail_pulita = email.strip()\nprint(f\"Email pulita: '{email_pulita}'\")\n\n# 3. Verifica se finisce con .com\nfinisce_con_com = email_pulita.endswith(\".com\")\nprint(f\"Finisce con .com? {finisce_con_com}\")\n\n# 4. Trova indice di '@'\nindice_chiocciola = email_pulita.find('@')\nprint(f\"Indice di '@': {indice_chiocciola}\")\n\n# 5. Estrai nome utente e dominio\nif indice_chiocciola != -1: # Assicurati che '@' sia presente\n    nome_utente = email_pulita[:indice_chiocciola]\n    dominio = email_pulita[indice_chiocciola + 1:]\n    # 6. Stampa nome utente e dominio\n    print(f\"Nome utente: {nome_utente}\")\n    print(f\"Dominio: {dominio}\")\nelse:\n    print(\"Formato email non valido.\")\n\n# 7. Sostituisci dominio\nnuova_email = email_pulita.replace(\"dominio.com\", \"nuovodominio.net\")\nprint(f\"Nuova email: {nuova_email}\")"
}
